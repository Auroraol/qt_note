# 网络编程

## 主机信息获取

```c++
QT       += network
```

```c++
#include <QHostInfo>
```

```c++
#include "widget.h"
#include "ui_widget.h"
#include <QHostInfo>  // 主机信息
#include <QString>
#include <QNetworkInterface>  // qnin
#include <QMessageBox>
Widget::Widget(QWidget* parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    getHostInfoation();
}

Widget::~Widget()
{
    delete ui;
}

// 获取主机信息
void Widget::getHostInfoation()
{
    // 获取主机名称
    QString localName = QHostInfo::localHostName();
    ui->lineEdit->setText(localName);
    // 根据主机名获得主机信息
    QHostInfo hostInfo = QHostInfo::fromName(localName);
    QList<QHostAddress> listAddress = hostInfo.addresses();
    if (!listAddress.isEmpty())
    {
        ui->lineEdit_2->setText(listAddress.first().toString());
    }
}


void Widget::on_pushButton_clicked()
{
    QString str;
    QList<QNetworkInterface> list = QNetworkInterface::allInterfaces();
    for (int i = 0; i < list.count(); i++)
    {
        QNetworkInterface interface = list.at(i);
        str += "设备名:" + interface.name() + "\n";
        str += "MAC地址:" + interface.hardwareAddress() + "\n";
        QList<QNetworkAddressEntry> entryList = interface.addressEntries();
        for(int j = 0; j < entryList.count(); j++)
        {
            QNetworkAddressEntry entry = entryList.at(0);
            str += "\tIP地址:" + entry.ip().toString() + "\n";  // ipv6的
            str += "\t子网掩码:" + entry.netmask().toString() + "\n";
            str += "\t广播播地址:" + entry.broadcast().toString() + "\n";
        }
    }
    QMessageBox::information(this, "详细信息", str);
}


```

效果:

![image-20220922142608842](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220922142608842.png)

<img src="%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220922142617494.png" alt="image-20220922142617494" style="zoom:50%;" />

![image-20220922202850531](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220922202850531.png)

大于   1024



## 知识点二十四: QT中的TCP通信

1. 连接服务器
   m_tcpSocket->connectToHost(“127.0.0.1”, 9877);
   connected = m_tcpSocket->waitForConnected();
   只有使用waitForConnected()后,QTcpSocket才真正尝试连接服务器，并返回是否连接的结果。
2. 写数据
   **m_tcpSocket->write(str.toStdString().c_str(), strlen(str.toStdString().c_str()));**
   m_tcpSocket->waitForBytesWritten();
   当使用waitForBytesWritten()后，QTcpSocket才真正发送数据。
   m_tcpSocket->write(str1.toStdString().c_str(), strlen(str1.toStdString().c_str()));
   m_tcpSocket->write(str2.toStdString().c_str(), strlen(str2.toStdString().c_str()));
   的结果是发送了str1str2
3. 断开与服务器的连接
   m_tcpSocket->disconnectFromHost()
   m_tcpSocket->waitForDisconnected()
4. 善于使用QTcpSocket的SIGNAL：connected()，disconnected()，error(QAbstractSocket::SocketError)
   配合自定义私有开关变量bool connected，QTimer可以实现自动重连接等逻辑。
5. 接收数据和发数据都是通讯套接字进行.



```
#include<QTcpServer>  // 监听套接字
#include<QtcpSocket>  // 通讯的套接字 “说剋特”
```

![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2Vla3Nvb28=,size_20,color_FFFFFF,t_70,g_se,x_16-164767323707627.png)



![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2Vla3Nvb28=,size_20,color_FFFFFF,t_70,g_se,x_16-164767355410129.png)

==下述代码只能一对一使用,  可以进行优化让服务端程序为若干客户端提供服务。比如使用io服用,或者其他==

### 服务器端：

**.pro文件；**

```c++
QT       += core gui network
```

**.h文件：**

```c++
#ifndef SERVER_H
#define SERVER_H

#include <QWidget>

#include<QtcpSocket>       // 通讯的套接字    “说剋特”
#include<QtcpSocket>       // 监听套接字

namespace Ui {
class Server;
}

class Server : public QWidget
{
    Q_OBJECT

public:
    explicit Server(QWidget *parent = 0);
    ~Server();

private:
    Ui::Server *ui;
    QTcpServer* tcpserver;                  //监听套接字
    QTcpSocket* clientConnection = null;    // 通讯的套接字
};

#endif // SERVER_H
```

**.cpp文件：**

```c++
#include "server.h"
#include "ui_server.h"

Server::Server(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Server)
{
    ui->setupUi(this);
        
    setWindowTitle("服务器");
    //ui实例化
    ui->sIp->setText("127.0.0.1");  //在sIp命名的文本窗口里设置127.0.0.1（本地）
    ui->sPort->setText("8888");  //客户端端口
        
   //init     
   tcpserver = new QTcpServer(this);   //内存回收机制，在执行析构函数时自动释放内存
   //监听（blind + listen） 第一个参数代表当前网卡所有的端口  参数: 客户端ip 服务器端口
   tcpserver->listen(QHostAddress::LocalHost，ui->lineEdit->text().toInt());
   // tcpserver->listen(QHostAddress::Any,8888) //QHostAddress::Any代表监听任意ip, 参数端口号只要跟客户端 一致即可
   // 一但客户端发起请求, 表示有新监听 // 连接成功会触发new connect信号, 接受信号【&QTcpServer::newConnection】 
   connect(tcpserver,&QTcpServer::newConnection,[=]() {
       
        //取出新的监听, 进行通讯 //接受客服端的套接字对象【及保存客户端的IP，port】
        clientConnection = tcpserver->nextPendingConnection();  
        //获取对方的ip和端口 
        QString ip   = clientConnection->peerAddress().toString();  //ip
        qint16  port = clientConnection->peerPort();                //port
        QString temp = QString("[%1:%2]:成功连接").arg(ip).arg(port);
        qdebug() << temp;

        //服务器接收数据，当服务器接收到数据时，会触发一个readready的信号
         connect(clientConnection, &QTcpSocket::readyRead,[=](){
             //从通信套接字中取出内容
             QByteArray array = clientConnection->readAll();  //接受读取数据
             ui->textEditRead->append(array); //append 追加
          });
    });
 }


void Server::on_btn_Send_clicked()
{
    if(NULL == clientConnection)  // 用通讯
    {
        qdebug() << "No connection!";
        return;
    }
   //获取编辑区的内容
    QString str = ui->textEditWrite->toPlainText();
    // 通过通讯的套接字, 发送给对方  // string 转char * 用 str.toUtf8().data()
    clientConnection->write(str.toUtf8().data());
    
    
}

void Server::on_btn_Close_clicked()
{
   if(NULL == clientConnection)
    {
        return;
    }
   //主动和客户端断开连接
   clientConnection->disconnectFromHost();  //断开连接
   clientConnection->close();
   clientConnection =NULL;

}

Server::~Server(){delete ui;}
```



// ip地址转成10进制形式

```c++
// ip地址转成10进制形式
QString Client::formatIP(QString ip)
{
    QString str;
    if (ip.contains(":"))
    {
        QStringList tmpList = ip.split(":");
        foreach(QString tmp, tmpList)
        {
            if (tmp.contains("."))
            {
                str = tmp;
                break;
            }
        }
    }
    else
    {
        str = ip;
    }
    return str;
}
```

==**要的：**==

+ **server->listen(QHostAddress(ui->sIp->text()),ui->sPort->text().toInt()   **
  + 建立连接**接受信号【&QTcpServer::newConnection】   用toInt（）转化成整形值**
+ **nextPendingConnection()接受客服端的套接字对象【及保存客户端的IP，port】**
+ **接受数据 【&QTcpSocket::readyRead】**
+ **conn->readAll();  接受读取数据**   
+ **发送数据【write（cahr *）】       .toPlainText().toUtf8().data()转换： 把QString转化成char ***
+ 

+++

### 客户端

客户端 .h 文件：

```c++
#ifndef CLIENT_H
#define CLIENT_H

#include <QWidget>
#include<QTcpSocket>
namespace Ui {
class Client;
}

class Client : public QWidget
{
    Q_OBJECT

public:
    explicit Client(QWidget *parent = 0);
    ~Client();

private:
    Ui::Client *ui;
    
    QTcpSocket* client;    // 通讯的套接字
};

#endif // CLIENT_H
```



客户端.cpp文件：

头文件

```c++
#include<QHostAddress>
```



```c++
#include "client.h"
#include "ui_client.h"
#include<QHostAddress>

Client::Client(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Client)
{
    ui->setupUi(this);
    //ui实例化
    ui->sIp->setText("127.0.0.1");
    ui->sPort->setText("9999");

    //init
    client = new QTcpSocket(this);
        
    //链接(建立链接）  连接服务器      参数: 服务器ip 服务器端口
    client->connectToHost(QHostAddress(ui->sIp->text()),ui->sPort->text().toInt());
        
    //接收数据:  [如果链接成功去]
    connect(client,&QTcpSocket::readyRead,this,[=](){
       //接受数据
        QByteArray array = client->readAll();  //client->readAll();读取数据    QByteArray array接受返回值
        ui->msg_record->append("对方说的：" + array);   //接受到的数据也放到聊天记录文本框
    });
        
        
    //发送数据
    connect( ui->send,&QPushButton::clicked,this,[=]()
    {
        client->write(ui->msg->toPlainText().toUtf8().data());  //访问发送的文本框内容，并发送数据   toPlainText()返回值是QString 而write（）接受值是char*或QBytearrayy
                                                              //把QString转化成QBytearrayy 用.toUtf8().data()转化
        ui->msg_record->append("Me Say: " + ui->msg->toPlainText() );  //在聊天记录文本框中显示聊天记录
        //clear
        ui->msg->clear();  //发送完成后清空
    });
}

Client::~Client()
{
    delete ui;

   
```

**要点：**//链接(建立链接）  连接服务器
    client->**connectToHost**(QHostAddress(ui->sIp->text()),ui->sPort->text().toInt())

+++

main.cpp文件：

```c++
#include "server.h"
#include <QApplication>
#include<client.h>           //添加客户端头文件

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    
    
    Server w;
    w.show();
    w.setWindowTitle("server");
    w.setFixedSize(714,650);

    Client c;
    c.show();
    c.setWindowTitle("client");
    c.setFixedSize(496,430);


    return a.exec();
}
```

###  例子2

```c++
#include "widget.h"
#include "ui_widget.h"
#include <QDebug>

Widget::Widget(QWidget* parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    setWindowTitle("服务器");
    ui->lineEdit_ip->setText("127.0.0.1");   // 服务器不需要写这个
    ui->lineEdit_port->setText("9961024");
    // init
    tcpserver = new QTcpServer(this);
    // 监听
    tcpserver->listen(QHostAddress::Any, ui->lineEdit_port->text().toInt());
    connect(tcpserver, &QTcpServer::newConnection, this, [ = ]()
    {
        clientConnection = tcpserver->nextPendingConnection();
        QString ip = clientConnection->peerAddress().toString();
        qint16  port = clientConnection->peerPort();
        QString temp = QString("[%1:%2]:成功连接").arg(ip).arg(port);
        ui->pushButton->setText(temp);
        // 连接
        connect(clientConnection, &QTcpSocket::readyRead, this, [ = ]()
        {
            QByteArray array = clientConnection->readAll();  //接受读取数据
            ui->textEdit_record->append("对方说的: " + array);
        });
    });
}



Widget::~Widget()
{
    delete ui;
}


void Widget::on_send_clicked()
{
    if (!clientConnection)
    {
        qDebug() << "No connection!";
        return;
    }
    QString str = ui->textEdit_data->toPlainText();
    clientConnection->write(str.toUtf8().data());
    ui->textEdit_record->append("自己说的: " + ui->textEdit_data->toPlainText());
    //clear
    ui->textEdit_data->clear();  //发送完成后清空
}


void Widget::on_close_clicked()
{
    if(!clientConnection)
    {
        qDebug() << "No connection!";
        return;
    }
    //主动和客户端断开连接
    clientConnection->disconnectFromHost();  //断开连接,保留缓冲区中的任何挂起数据  abort()是不保留
    clientConnection->close();
    clientConnection = NULL;
    ui->pushButton->setText("断开连接");
}


```



```c++
#include "widget.h"
#include "ui_widget.h"
#include<QHostAddress>

Widget::Widget(QWidget* parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    setWindowTitle("客户端");
    ui->lineEdit_ip->setText("127.0.0.1");
    ui->lineEdit_port->setText("9961024");
    ui->pushButton->setText("未连接");
    //init
    client = new QTcpSocket(this);
    //链接(建立链接）  连接服务器
    client->connectToHost(QHostAddress(ui->lineEdit_ip->text()), ui->lineEdit_port->text().toInt());
    connect(client, &QTcpSocket::readyRead, this, [ = ]()
    {
        ui->pushButton->setText("连接成功");
        //接受数据
        QByteArray array = client->readAll();  //client->readAll();读取数据    QByteArray array接受返回值
        ui->textEdit_record->append("对方说的：" + array);   //接受到的数据也放到聊天记录文本框
    });
}

Widget::~Widget()
{
    delete ui;
}



void Widget::on_send_clicked()
{
    //发送数据
    client->write(ui->textEdit_data->toPlainText().toUtf8().data());  //访问发送的文本框内容，并发送数据   toPlainText()返回值是QString 而write（）接受值是char*或QBytearrayy
    //把QString转化成QBytearrayy 用.toUtf8().data()转化
    ui->textEdit_record->append("自己说的: " + ui->textEdit_data->toPlainText());  //在聊天记录文本框中显示聊天记录
    //clear
    ui->textEdit_data->clear();  //发送完成后清空
}
```

<img src="%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20221025150607391.png" alt="image-20221025150607391" style="zoom:50%;" />

### 状态判断



### 聊天室

#### 服务器程序

```cpp
//server.h
#pragma once
#include <QTcpServer>
#include <QTcpSocket>
#include <QDebug>
#include <QList>
#include <QTimer>
#include <iostream>
class server : public QObject
{
    Q_OBJECT
private:
    QTcpServer tcpServer;   // 监听套接字
    quint16 port;                      //服务器端口
    QList<QTcpSocket*> tcpClientList;  //保存所有和客户端通信的套接字
    QTimer timer;

public:
    void startServer(int port);
    explicit server(QObject* parent = 0);
    ~server();
public slots:
    void onNewConnection(); //响应客户端连接请求的函数
    void onReadyRead();     //接收客户端消息的槽函数
    void sendMessage(const QByteArray& buf);

    //定义时间超出的槽函数
    void onTimeOut(void);
};

```

```c++
#include "server.h"

#include <QApplication>

int main(int argc, char* argv[])
{
    QApplication a(argc, argv);
    server test;
    return a.exec();
}

```

```c++
#include "server.h"

server::server(QObject* parent): QObject(parent)
{
    startServer(8081);  //启动
    //当有客户端向服务器发送连接请求,发送信号:newConnection
    connect(&tcpServer, SIGNAL(newConnection()),
            this, SLOT(onNewConnection()));
    //  connect(&tcpServer, &QTcpServer::newConnection, this, &server::onNewConnection);
    //定时器到时发送信号:timeout
    connect(&timer, SIGNAL(timeout()),
            this, SLOT(onTimeOut()));
}
server::~server()
{
    qDebug() << "stop server";
}

void server::startServer(int port)
{
    this->port = port;
    if (tcpServer.listen(QHostAddress::Any, port) == true)  //监听
    {
        qDebug() << "Server starts success, listening port number is" << port << ".";
        //开启定时器
        timer.start(3000);
    }
    else
    {
        qDebug() << "The server starts failed, please confirm if the port number is occupied.";
    }
}

void server::onNewConnection() //响应客户端连接请求的函数
{
    //保存套接字到容器
    QTcpSocket* tcpClient = tcpServer.nextPendingConnection();
    tcpClientList.append(tcpClient);
    //当客户端向服务器发送信息时,通信套接字发送信号:readyRead //  // 连接
    connect(tcpClient, SIGNAL(readyRead()), this, SLOT(onReadyRead()));
}

void server::onReadyRead() //接收客户端消息的槽函数
{
    //遍历容器哪个客户端给服务器发送了消息
    for (int i = 0; i < tcpClientList.size(); i++)
    {
        // bytesAvailable:获取当前套接字等待读取消息字节数
        //返回0表示没有消息
        //返回大于0说明当前套接字有消息到来
        if (tcpClientList.at(i)->bytesAvailable())
        {
            //读取消息并保存
            QByteArray buf = tcpClientList.at(i)->readAll();
            qDebug() << buf;
            sendMessage(buf);
        }
    }
}

//发送消息的槽函数
void server::sendMessage(const QByteArray& buf)
{
    //发送给所有建立连接的人
    for (int i = 0; i < tcpClientList.size(); i++)
    {
        //发送消息
        tcpClientList.at(i)->write(buf);
    }
}

void server::onTimeOut(void)
{
    unsigned int tcpClientSize = tcpClientList.size();
    qDebug() << "当前连接数:" << tcpClientSize;
    //遍历检查容器中保存的客户端通信套接字是否已经断开连接,如果是则删除
    for (unsigned int i = 0; i < tcpClientSize; i++)
    {
        if (tcpClientList.at(i)->state() == QAbstractSocket::UnconnectedState) // state是套接字状态,用来标识连接状态
        {
            tcpClientList.removeAt(i);
            --i;             //保证删除掉一个元素后依旧能遍历全部元素
            --tcpClientSize; //删除掉一个后元素量也少了一个
        }
    }
    //容器
}
```

 最终结果

![在这里插入图片描述](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/c2c3675c092a4faebdf6cfe0541d1f4a.png)

####  客户端程序

```cpp
//dialog.h
#ifndef DIALOG_H
#define DIALOG_H

#include <QDialog>
#include <QTcpSocket>
#include <QHostAddress>
#include <QMessageBox>
#include <QDebug>
QT_BEGIN_NAMESPACE
namespace Ui
{
    class Dialog;
}
QT_END_NAMESPACE

class Dialog : public QDialog
{
    Q_OBJECT

public:
    explicit Dialog(QWidget* parent = nullptr);
    ~Dialog();
public slots:
    //发送按钮对应的槽函数
    void on_sendButton_clicked();
    //连接服务器按钮对应的槽函数
    void on_connectButton_clicked();
    //和服务器连接成功的槽函数
    void onConnected();
    //和服务器连接断开时执行的槽函
    void onDisconnected();
    //接收聊天消息的槽函数
    void onReadyRead();
    //网络异常执行的槽函数
    void onError();
private:
    Ui::Dialog* ui;
    bool status;//标识状态:在线还是离线
    QTcpSocket tcpSocket;//和服务器通信的套接字
    QHostAddress serverIP;//服务器地址
    quint16 serverPort;
    QString username;
};
#endif // DIALOG_HA
```

```c++
//main.cpp
#include "dialog.h"

#include <QApplication>

int main(int argc, char* argv[])
{
    QApplication a(argc, argv);
    Dialog w;
    w.show();
    return a.exec();
}


```

```c++
//dialog.cpp
#include "dialog.h"
#include "ui_dialog.h"

Dialog::Dialog(QWidget* parent)
    : QDialog(parent)
    , ui(new Ui::Dialog)
{
    ui->setupUi(this);
    status = false;//离线状态
    connect(&tcpSocket, SIGNAL(connected()), this, SLOT(onConnected()));
    connect(&tcpSocket, SIGNAL(disconnected()), this, SLOT(onDisconnected()));
    connect(&tcpSocket, SIGNAL(readyRead()), this, SLOT(onReadyRead()));
    connect(&tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(onError()));
}

Dialog::~Dialog()
{
    delete ui;
}

//发送按钮对应的槽函数
void Dialog::on_sendButton_clicked()
{
    qDebug() << "1";
    //获取用户输入的聊天消息
    QString msg = ui->messageEdit->text();
    if(msg == "")
    {
        return ;
    }
    msg = username + ":" + msg;
    //发送消息
    tcpSocket.write(msg.toUtf8());
    //清空消息输入框
    ui->messageEdit->clear();
    qDebug() << "1";
}

//连接服务器按钮对应的槽函数
void Dialog::on_connectButton_clicked()
{
    qDebug() << "2";
    //如果是离线状态,则建立和服务器连接
    if(status == false)
    {
        //获取服务器IP地址
        serverIP.setAddress(ui->serverIpEdit->text());
        qDebug() << serverIP;
        //获取服务器端口
        serverPort = ui->serverPortEdit->text().toUShort();
        qDebug() << serverPort;
        //获取聊天室称呼
        username = ui->usernameEdit->text();
        qDebug() << username;
        //向服务器发送连接请求
        tcpSocket.connectToHost(serverIP, serverPort);
        //成功发送信号:connected
        //失败发送信号:error
    }
    //如果时在线状态,则断开连接
    else
    {
        qDebug() << "断开连接";
        //向服务器发送离开聊天室的提示消息
        QString msg = username + "离开聊天室";
        tcpSocket.write(msg.toUtf8());
        //关闭和服务器的连接,同时发送信号:disconnected
        tcpSocket.disconnectFromHost();
    }
    qDebug() << "2";
}
//和服务器连接成功的槽函数
void Dialog::onConnected()
{
    qDebug() << "3";
    status = true;//更改状态为在线
    ui->sendButton->setEnabled(true);
    ui->serverIpEdit->setEnabled(false);
    ui->serverPortEdit->setEnabled(false);
    ui->usernameEdit->setEnabled(false);
    ui->connectButton->setText("离开聊天室");
    //向服务器发送进入聊天室提示消息
    QString msg = username + "进入聊天室";
    //toUtf8:QString转换为QByteArray
    tcpSocket.write(msg.toUtf8());
    qDebug() << "3";
}
//和服务器连接断开时执行的槽函
void Dialog::onDisconnected()
{
    qDebug() << "4";
    status = false;
    ui->sendButton->setEnabled(false);
    ui->serverIpEdit->setEnabled(true);
    ui->serverPortEdit->setEnabled(true);
    ui->usernameEdit->setEnabled(true);
    ui->connectButton->setText("连接服务器");
    qDebug() << "4";
}
//接收聊天消息的槽函数
void Dialog::onReadyRead()
{
    qDebug() << "5";
    if(tcpSocket.bytesAvailable())
    {
        //接收消息
        QByteArray buf = tcpSocket.readAll();
        //显示消息
        ui->listWidget->addItem(buf);
        ui->listWidget->scrollToBottom();
    }
    qDebug() << "5";
}
//网络异常执行的槽函数
void Dialog::onError()
{
    qDebug() << "6";
    //errorString():获取网络异常的原因
//    QMessageBox::critical(this,"ERROR",tcpSocket.errorString());
    qDebug() << "6";
}


```

```
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>314</width>
    <height>428</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <widget class="QWidget" name="">
   <property name="geometry">
    <rect>
     <x>30</x>
     <y>40</y>
     <width>258</width>
     <height>360</height>
    </rect>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QListWidget" name="listWidget"/>
    </item>
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <item>
       <widget class="QLineEdit" name="messageEdit"/>
      </item>
      <item>
       <widget class="QPushButton" name="sendButton">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>send</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item>
     <layout class="QFormLayout" name="formLayout">
      <item row="0" column="0">
       <widget class="QLabel" name="label">
        <property name="text">
         <string>服务器地址</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QLineEdit" name="serverIpEdit">
        <property name="text">
         <string>192.168.10.94</string>
        </property>
       </widget>
      </item>
      <item row="1" column="0">
       <widget class="QLabel" name="label_2">
        <property name="text">
         <string>服务器端口</string>
        </property>
       </widget>
      </item>
      <item row="1" column="1">
       <widget class="QLineEdit" name="serverPortEdit">
        <property name="text">
         <string>8081</string>
        </property>
       </widget>
      </item>
      <item row="2" column="0">
       <widget class="QLabel" name="label_3">
        <property name="text">
         <string>称呼</string>
        </property>
       </widget>
      </item>
      <item row="2" column="1">
       <widget class="QLineEdit" name="usernameEdit">
        <property name="text">
         <string>a</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item>
     <widget class="QPushButton" name="connectButton">
      <property name="text">
       <string>连接服务器</string>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
```

  成果

![在这里插入图片描述](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASy1E5bCP5piK,size_20,color_FFFFFF,t_70,g_se,x_16.png)



###   传输图片



```
 showPic_.loadFromData(picData);   //从QByteArray中加载
```





/// 不用下面这样转换

 1.1 图片编码和解码

png编码为[base64](https://so.csdn.net/so/search?q=base64&spm=1001.2101.3001.7020)数据 ：（用于客服端传输）

```cpp
QByteArray Client::getImageData(const QImage &image)
{
    QByteArray imageData;
    QBuffer buffer(&imageData);
    image.save(&buffer, "png");
    imageData = imageData.toBase64();
    
    return imageData;
}
```

base64数据解码为png ：（用于客服端传输）

```cpp
QImage Server::getImage(const QString &data)
{
    QByteArray imageData = QByteArray::fromBase64(data.toLatin1());
    QImage image;
    image.loadFromData(imageData);
    return image;
}
```

 1.2 图片显示(合理缩放图像以填充label)

```cpp
           QImage imageData = getImage(imageContent);
            QPixmap resImage = QPixmap::fromImage(imageData);
            QPixmap* imgPointer = &resImage;
            imgPointer->scaled(ui->imageLabel->size(), Qt::IgnoreAspectRatio);//重新调整图像大小以适应窗口
            //法二：替换前面的表达式
           // imgPointer->scaled(ui->imageLabel->size(), Qt::KeepAspectRatio);//设置pixmap缩放的尺寸

            ui->imageLabel->setScaledContents(true);//设置label的属性,能够缩放pixmap充满整个可用的空间。
            ui->imageLabel->setPixmap(*imgPointer);
```

![img](../QT%25E7%25AC%2594%25E8%25AE%25B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzc1NTk4,size_16,color_FFFFFF,t_70%252523pic_center.png)

  TCP知识

如果只是发送空的图片，就是只有TCP报头的数据报，大小为20字节。

一般以太网帧的大小为[64,1518]，除去帧头14字节（6字节目的MAC地址，6字节目的MAC地址，2字节Tye域值）、4字节帧尾（CRC校验），剩下大小为[64,1500]字节，不足64字节会被当作无效帧（因为争用期的存在，即确保在发送数据的同时检测到可能存在的冲突【CSMA/CD协议】）。

一个TCP报文大小最大为1500-20（IP头）-20（TCP头）=1460字节；
一个UPD报文最大为1500-20（IP头）-8（UPD头）=1482字节。

TCP全靠IP曾来分帧（流协议），TCP协议本身会进行拥赛和流利控制。



**代码:  QtTcpImage-master**











## 知识点二十五: QT中的UDP通信

//UDP协议:用户数据报协议，无连接状态,不可靠传输，丢包相当于写信

![image-20220922161458106](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220922161458106.png)

端口号

**.pro文件；**   

```
+= core gui network
```

*.h文件：

```c++
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include<QUdpSocket>

namespace Ui {
class Widget;
}

class Widget : public QWidget
{
    Q_OBJECT

public:
    explicit Widget(QWidget *parent = 0);
    ~Widget();

private:
    Ui::Widget *ui;
    
    QUdpSocket* udp1;        // 通讯的套接字

};

#endif // WIDGET_H
```

### 服务器端

**.cpp文件：**

```c++
#include "widget.h"
#include "ui_widget.h"
#include<QHostAddress>

Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
{
    ui->setupUi(this);
        
    ui->cIp->setText("127.0.0.1");
    ui->cPort->setText("9999");
        
    ui->sPort->setText("8888");  //服务器端口
    //init初始化
    udp1 = new QUdpSocket(this);
    //如果要接收必须绑定端口  //绑定自己的端口
    udp1->bind(ui->sPort->text().toInt());
        
        
    //send msg发送数据       （不能保证在连接成功的情况下接受数据）
    connect(ui->send,&QPushButton::clicked,this,[=]()
    {
        udp1->writeDatagram(ui->msg->toPlainText().toUtf8().data(), QHostAddress(ui->cIp->text()),ui->cPort->text().toInt() ); //QHostAddress(ui->cIp->text(),ui->cPort->text().toInt(
                                                                                                                             //对方的
        ui->msg_record->append("My say: " + ui->msg->toPlainText());
        ui->msg->clear();     //清理msg
    });
        
        
    //read msg接受数据：
    connect(udp1,&QUdpSocket::readyRead,this,[=]
    {
        qint64 size = udp1->pendingDatagramSize();   //pending待定   Datagram数据报
        QByteArray array(size,0);
        udp1->readDatagram(array.data(),size);
        
        ui->msg_record->append("对方： " + array);

    });
}

Widget::~Widget()
{
    delete ui;
}
```

客户端 .h 文件：没有添加的

### **客户端**

**.cpp文件：**

```c++
#include "client.h"
#include "ui_client.h"

Client::Client(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Client)
{
    ui->setupUi(this);

    ui->setupUi(this);
    ui->sIp->setText("127.0.0.1");
    ui->sPort->setText("8888");
        
    ui->cPort->setText("9999"); //自己的端口

    udp2 = new QUdpSocket(this);
    //如果要接收必须绑定端口  // 让别人找的到自己
    udp2->bind(ui->cPort->text().toInt());
        
        
    //send msg 指定要发送的客户端IP和端口
    connect(ui->send,&QPushButton::clicked,this,[=]
    {
        udp2->writeDatagram(ui->msg->toPlainText().toUtf8().data(),QHostAddress(ui->sIp->text()),ui->sPort->text().toInt());
        ui->msg_record->append("My say: " + ui->msg->toPlainText());
        ui->msg->clear();
    });
        
        
    //read msg、接受数据
    connect(udp2,&QUdpSocket::readyRead,this,[=]{

        qint64 size = udp2->pendingDatagramSize();
        QByteArray array(size,0);
        udp2->readDatagram(array.data(),size);

        ui->msg_record->append("对方: " + array);
    });

}

Client::~Client()
{
    delete ui;
}

```

![在这里插入图片描述](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/bd69de69a88e4bfab5cb649ddec9b6eb.gif)



==要点：==

+ **bind(ui->sPort->text().toInt())    直接建立连接，不用监听**

* **发送数据 writeDatagram**      .toPlainText().toUtf8().data()转换： 把QString转化成QBytearrayy****

+ **接受数据 【&QTcpSocket::readyRead】****

  + **qint64 size = udp1->pendingDatagramSize();   //pending待定   Datagram数据报**

  ​       **QByteArray array(size,0);**
  ​       **udp1->readDatagram(array.data(),size);**



## 知识点二 十六: QT广播/组播

### **广播**：UDP

> 例如前面在UDP中， 我们发送信息都是指定发送的内容，对方的IP地址和对方的端口号，相当于给一个人发信息。广播的意义在于给好多人发消息。
> .
> **于是IP换一下就成为广播了**

![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2Vla3Nvb28=,size_20,color_FFFFFF,t_70,g_se,x_16-164767917981534.png)



**组播**

> 例如服务器要进行组播,组播的话要进行设置组播段号,同时还需要要自身绑定更改

![image-20220319164310017](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220319164310017.png)



## 知识点二十七: TCP文件传输

![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/V244FV%25%254NV71PS%25G_BW%60R.png)



![image-20220319164657448](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220319164657448.png)

![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2Vla3Nvb28=,size_20,color_FFFFFF,t_70,g_se,x_16.png)



### **服务端**：

```c++
#ifndef SERVER_H
#define SERVER_H

#include <QWidget>
#include<QTcpServer>
#include<QTcpSocket>
#include<QFile>
#include<QTimer>
namespace Ui {
class Server;
}

class Server : public QWidget
{
    Q_OBJECT

public:
    explicit Server(QWidget *parent = 0);
    void sendData(); //接受文件数据
    ~Server();

private:
    Ui::Server *ui;
    QTcpServer* watch;
    QTcpSocket* chat;

};

#endif // SERVER_H
```

![img](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2Vla3Nvb28=,size_20,color_FFFFFF,t_70,g_se,x_16-16476828244772.png)

```c++
#include "server.h"
#include "ui_server.h"
#include <QFile>
#include <QFileDialog>
#include <QMessageBox>
#include <QTimer>
#include <QPushButton>

Server::Server(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Server)
{
    ui->setupUi(this);
    //监听套接字
    watch =new QTcpServer(this);

    //监听  这里是任意 IP 但是指定了端口号
    if (watch->listen( QHostAddress::Any , 77 ))
    {
        qdebug() << watch->errorString();
        close();
	}

    //如果有新的连接  watch相对与之前的serrver都是命名
    connect( watch ,&QTcpServer::newConnection,   this, [=]()
    {

        //接收客户端套接字对象,从连接请求中选择一个请求连接
        chat = watch->nextPendingConnection();

        //获取对方的ip和端口：
        QString ip = chat->peerAddress().toString();
        quint16 sort = chat->peerPort();
        
		//input1是文本框命称
        ui->input1->append( QString("连接成功%1:%2").arg(ip).arg(sort) );
        ui->input1->append("请选则你要传输的文件" );
    });

        
    //选择文件 + 读取文件：
     connect(ui->choose1 , &QPushButton::clicked , this, [=]()
     {
        QString filepath = QFileDialog::getOpenFileName ( this ,  "请选择文件" , "e\\" );
        if( filepath.isEmpty() == true  )
            QMessageBox::warning (this  ,   "警告" , "文件打开失败");
      
        //文本框里显示文件路径：
        ui->input1->append(filepath);

        //获取文件的名字和大小
        QFileInfo qfi(filepath) ;
        //为头报文做准备    
        QString filename= qfi.fileName();
        qint64 filesize = qfi.size();

        //设置已发送大小变量
         qint64 sendsize = 0;

         //读取文件
        QFile file；
        file.setFileName(filepath) ;    //or QFile file(filepath)
        bool a = file.open(QFile::ReadOnly);
        if (a == false)
        {
            QMessageBox::critical (this  ,   "警告" , "文件读取失败");
            return ;
        }
    });

   QTimer timer = new QTimer(this);
   connect (&timer ,&QTimer::timeout , this , [=](){
        //先关闭定时器要用的时候开启
       timer.stop();
       // 调用自定义的函数：
       sendData();  
    });

   //发送按钮
   connect(ui->send1 , &QPushButton::clicked , this, [=]()
   {
         //【先】发送头报文
         QString  head = QString("%1##%2").arg(filename).arg(filesize);

         qint64 len_head = chat->write( head.toUtf8() );   
      /* tcp 通讯的：
        conn->write(ui->msg->toPlainText().toUtf8().data());  
       //访问发送的文本框内容，并发送数据  
       //toPlainText()返回值是QString 而write（）接受值是char*或QBytearrayy
        //把QString转化成QBytearrayy 用.toUtf8().data()转化
       */
       
      
         if (len_head > 0)         //如果发送的投报文有就执行
         {
            timer.start(1000) ;   //开启定时器
            ui->input1->append("正在发送文件");
         }
         else
         {
           qDebug()<<"头部信息发送失败" ;
           file.close();
         }
   });
}

//自定义的函数：
void Server::sendData(){

    //发送文件信息

    //发送文件
    qint64 len = 0 ;

    do{
        //设置,每次发送的大小为4k 
        char buf[4*1024]= {0};

        //读入源文件数据read（）
        len= file.read(buf , sizeof(buf) );

        //发出数据 （这里是读多少,发送多少）
        len = chat->write( buf , len);

        //发送数据需要累积
        sendsize = sendsize + len;

    }while(len>0 );   //只要len>0 就不断循环do中的内容

    if (filesize == sendsize)
        {

        ui->input1->append("发送成功");
        file.close();

        //把客户端关了
        chat->disconnectFromHost();
        chat->close();
    }
}


Server::~Server(){ delete ui;}

```

+++

###  **客户端**：

```c++
#ifndef CLIENT_H
#define CLIENT_H

#include <QWidget>
#include<QTcpSocket>
#include<QFile>

namespace Ui {
class client;
}

class client : public QWidget
{
    Q_OBJECT

public:
    explicit client(QWidget *parent = 0);
    ~client();

private:
    Ui::client *ui;
    QTcpSocket* chat1;
    QFile file;
    QString filename;
    qint64 filesize;
    qint64 recevesize;

    bool a;

};

#endif // CLIENT_H
```

```c++
#include "client.h"
#include "ui_client.h"
#include <QMessageBox>
#include<QHostAddress>

client::client(QWidget* parent) :
    QWidget(parent),
    ui(new Ui::client)
{
    ui->setupUi(this);
    chat1 = new QTcpSocket;
    a = true ;
    connect( ui->connect,  &QPushButton::clicked, this,  [ = ]()
    {
        QString ip = ui->ip->text();
        qint16 sort = ui->port->text().toInt();
        //连接服务器 connectToHost
        chat1->connectToHost(QHostAddress(ip), sort);
    } );
    //接受数据
    connect ( chat1, &QTcpSocket::readyRead, this, [ = ]()
    {
        QByteArray bta = chat1->readAll();    //发的就是头报文
        qDebug() << bta;
        if(true == a )
        {
            //用a ==true,表示接受头部信息
            a = false ;
            //下一次执行else的代码去判断是否接受完毕（因为服务器是用循环一部分一部分发送的）
            //解析头 ,字节数组转换为QString
            filename = QString(bta).section("##", 0, 0);
            filesize = QString(bta).section("##", 1, 1).toInt();
            recevesize = 0;
            qDebug() << "文件名称: " << filename << " 文件大小: " << filesize ;
            //打开文件(不会显示的)
            file.setFileName("C:\\Users\\16658\\Desktop\\" + filename);
            bool ab = file.open(QFile::WriteOnly);
            if (ab == false)
            {
                QMessageBox::critical (this,  "警告", " 接受文件失败");
            }
        }
        else  //文件信息
        {
            qint64 len = file.write(bta);  //这里的write是文件的读写
            recevesize = len + recevesize;
            if (recevesize == filesize)
            {
                file.close();
                QMessageBox::information(this, "恭喜", "文件接受完成");
                //关掉连接
                chat1->disconnectFromHost();
                chat1->close();
            }
        }
    });
}
client::~client()
{
    delete ui;
}
```

效果：

![image-20220319195502998](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20220319195502998.png)

+++



## Qt实现HTTP客户端操作

**QNetworkAccessManager**

[(22条消息) Qt网络编程：QNetworkAccessManager*友善啊，朋友的博客-CSDN博客*qnetworkaccessmanager](https://blog.csdn.net/kenfan1647/article/details/118314984)

网络访问API围绕一个QNetworkAccessManager对象构建，该对象包含其发送的请求的通用配置和设置。它包含代理和缓存配置，以及与此类问题相关的信号，以及可用于监控网络操作进度的回复信号。由QNetworkAccessManager基于QObject，因此只能从它所属的线程中使用它。

```c++
//构建一个manager对象
QNetworkAccessManager *manager = new QNetworkAccessManager(this); 
//manager具有异步API，当http请求完成后，会通过finished信号进行通知
connect(manager,&QNetworkAccessManager::finished,this, [ = ](QNetworkReply * reply){
    QString data = reply->readAll(); // uir的内容json内容
    // 进行Qjson操作
} 

//发送异步get请求, 发送请求
manager->get(QNetworkRequest(QUrl("http://qt-project.org")));
```

**服务请求QNetworkRequest**

[(22条消息) Qt网络编程：QNetworkRequest_友善啊，朋友的博客-CSDN博客_qnetworkrequest](https://blog.csdn.net/kenfan1647/article/details/118279141)

要发起一个get/post请求，首先要构建一个QNetworkRequest对象作为参数，它包含一个URL和一些可用于修改请求的辅助信息。

```cpp
//构建请求对象
QString url = "http://iwxyi.com:3000/search?keywords=" + songName.toUtf8().toPercentEncoding();
QNetworkRequest* request = new QNetworkRequest(url);
request->setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded; charset=UTF-8"); //在请求中，有一种数据传输的Content-Type 是application/x-www-form-urlencoded。
request->setHeader(QNetworkRequest::UserAgentHeader, "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36");

//发送请求
//manager->get(request);
//manager->post(request, QByteArray());
//manager->put(request, QByteArray());
```

有时需要在url中携带参数，如果手动进行字符串拼接不是很方便。Qt5.0提供了 QUrlQuery类，可以很方便的拼接和解析url中的参数。

```cpp
QUrl url("http://httpbin.org/get");
    
//拼接
QUrlQuery query;
query.addQueryItem("ie","utf-8");
url.setQuery(query);
qDebug()<<url;
//QUrl("http://httpbin.org/get?ie=utf-8")
    
//解析
QUrlQuery query2(url);
if(query2.hasQueryItem("ie"))
    qDebug()<<query2.queryItemValue("ie");
//"utf-8"
```

 **服务响应QNetworkReply**

**调用manager的get、post等接口后会返回一个reply对象**，在manager的finished信号种也会传递该reply对象。如果要同步处理就在get、post后用事件循环等finished信号，如果是异步处理直接关联finished信号到槽即可。

注意 get/post 返回的 QNetworkReply 需要自己释放，Qt 5.14 可以设置 QNetworkAccessManager 的 setAutoDeleteReplies(true) 自动释放，Qt 5.15 又新增了 setTransferTimeout 设置超时时间。

使用入同步处理:

```c++
//同步处理，可以开启一个局部的事件循环，等待响应，不会阻塞线程
QNetworkReply *reply=manager->get(request);
QEventLoop eventLoop;
connect(reply, &QNetworkReply::finished, &eventLoop, &QEventLoop::quit);
eventLoop.exec();             
//处理reply信息
receiveReply(reply); 
```

使用异步处理：

```c++
//connect(manager,&QNetworkAccessManager::finished,this,&MyClass::replyFinished); 
//槽函数
void MyClass::replyFinished(QNetworkReply *reply)
{
    if(reply->error()!=QNetworkReply::NoError){
        //处理中的错误信息
        qDebug()<<"reply error:"<<reply->errorString();
    }else{
        //请求方式
        qDebug()<<"operation:"<<reply->operation();
        //状态码
        qDebug()<<"status code:"<<reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        qDebug()<<"url:"<<reply->url();
        //qDebug()<<"raw header:"<<reply->rawHeaderList();
 
        //获取响应信息
        const QByteArray reply_data=reply->readAll();
        qDebug()<<"read all:"<<reply_data;
 
        //解析json
        QJsonParseError json_error;
        QJsonDocument document=QJsonDocument::fromJson(reply_data, &json_error);
        if(json_error.error==QJsonParseError::NoError){
            if(document.isObject()){
                const QJsonObject obj=document.object();
                qDebug()<<obj;
                if(obj.contains("args")){
                    QJsonValue value=obj.value("args");
                    qDebug()<<value;
                    //QJsonValue(object, QJsonObject({"ie":"utf-8"}))
                }
            }
        }else{
            qDebug()<<"json error:"<<json_error.errorString();
        }
    }
    reply->deleteLater();
}
```

访问有些网页会返回301/302状态码，需要重新请求重定向的地址。

```c++
if (status_code == 301 || status_code == 302){
      // Or the target URL if it was a redirect:
      QVariant redirectionTargetUrl =reply->attribute(QNetworkRequest::RedirectionTargetAttribute);
      //qDebug() << "redirection Url is " << redirectionTargetUrl.toString();
      QUrl url(redirectionTargetUrl.toString());
      manager->get(QNetworkRequest(url));
}
```

也可以用定时器定时来调用reply的abort或者close，会提前finished终止当前任务。Qt 5.15 新增了 setTransferTimeout 接口，可对 QNetworkRequest 或是 QNetworkAccessManager 设置。

```cpp
//超时处理，可以使用定时器调用abort、close来终止当前的请求
QNetworkReply *reply=manager->get(request);
if(reply->isRunning()){
    QTimer *timer=new QTimer(reply);//对象树关联释放，也可以在finish进行释放
    timer->setSingleShot(true);
    //超时就结束，abort后状态码为0，错误信息为"Operation canceled"
    connect(timer,&QTimer::timeout,reply,&QNetworkReply::abort);
    //结束就关定时器
    connect(reply,&QNetworkReply::finished,timer,&QTimer::stop);
    //定时
    timer->start(5000);
}
```

 **表单数据QHttpMultiPart与QHttpPart**

HTTP表单提交需要借助QHttpMultiPart与QHttpPart两个类，官方文档有个小示例（直接F1查看QHttpMultiPart），我这里稍加修改使之可以正常使用。

示例中图片的ContentDispositionHeader没有添加filename，导致测试时提交失败。示例中也没有设置Boundary分隔符，导致我提交到我们公司服务器时失败，加上就好了。这些应该都和服务器的设置有关。

```c++
void test(){    
    QNetworkAccessManager *manager=new QNetworkAccessManager(this);
 
    //构建一个multiPart用于提交表单
    //注意，multiPart请在请求完成后再删除
    QHttpMultiPart *multiPart=new QHttpMultiPart(QHttpMultiPart::FormDataType);
 
    //文本内容
    QHttpPart namePart;
    //Content-Type对照表详情百度http://tool.oschina.net/commons/
    namePart.setHeader(QNetworkRequest::ContentTypeHeader,QVariant("text/plain"));
    namePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"thename\";"));
    namePart.setBody("gongjianbo");
    QHttpPart agePart;
    agePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"theage\";"));
    agePart.setBody("27");
    multiPart->append(namePart);
    multiPart->append(agePart);
 
    //文件内容
    QHttpPart filePart;
    filePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain")); //貌似我们公司我用application也行
    //示例里没有filename，导致提交不成功
    filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"thefile\";filename=\"file.txt\";"));
    QFile *textFile = new QFile("./Src/file.txt");
    textFile->setParent(multiPart); //在删除reply时一并释放
    if(textFile->open(QIODevice::ReadOnly)){
        //要读取小块数据，请使用setBody(); 对于像图像这样的较大数据块，请使用setBodyDevice()。
        filePart.setBodyDevice(textFile);
        multiPart->append(filePart);
    }
 
    //图片内容
    QHttpPart imagePart;
    imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/png"));
    //示例里没有filename，导致提交不成功
    imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"theimage\";filename=\"image.png\";"));
    QFile *imageFile = new QFile("F:/Src/image.png");
    imageFile->setParent(multiPart); //在删除reply时一并释放
    if(imageFile->open(QIODevice::ReadOnly)){
        imagePart.setBodyDevice(imageFile);
        multiPart->append(imagePart);
    }
 
    //在我们公司里使用的时候，没有Boundary也会导致提交不成功
    multiPart->setBoundary("qtdata");
    QNetworkRequest request(QUrl("http://httpbin.org/post"));
    request.setRawHeader("Content-Type","multipart/form-data;boundary=qtdata");
 
    //提交表单
    QNetworkReply *reply=manager->post(request,multiPart);
    multiPart->setParent(reply); //在删除reply时一并释放
 
    QEventLoop eventLoop;
    connect(reply, &QNetworkReply ::finished, &eventLoop, &QEventLoop::quit);
    eventLoop.exec();
 
    qDebug()<<reply->readAll();
    reply->deleteLater();
}
```

### 使用

```c++
#include "MainWidget.h"
#include "ui_MainWidget.h"

#include <QUrlQuery>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>

#include <QDebug>

MainWidget::MainWidget(QWidget* parent) :
    QWidget(parent),
    ui(new Ui::MainWidget)
{
    ui->setupUi(this);
    manager = new QNetworkAccessManager(this);
    //查看支持的协议
    qDebug() << manager->supportedSchemes();
    qDebug() << "OpenSSL支持情况:" << QSslSocket::supportsSsl();   //安装了openssl，会有https
    //QNetworkAccessManager是异步的, manager具有异步API，当http请求完成后，会通过finished信号进行通知
    connect(manager, &QNetworkAccessManager::finished, this, &MainWidget::receiveReply);
    //测试get
    connect(ui->btnGet, &QPushButton::clicked, this, &MainWidget::getTest);
    //测试post
    connect(ui->btnPost, &QPushButton::clicked, this, &MainWidget::postTest);
    //测试form
    connect(ui->btnForm, &QPushButton::clicked, this, &MainWidget::formTest);
    //定时器拿来验证是否阻塞界面
    connect(&timer, &QTimer::timeout, this, [this]()
    {
        ui->editTime->setTime(QTime::currentTime());
    });
    timer.start(1000); //定时1s
}

MainWidget::~MainWidget()
{
    delete ui;
}

void MainWidget::getTest()
{
    //构建请求对象
    QNetworkRequest request;
    /*
    // 发送https请求前准备工作;
    QSslConfiguration config;
    QSslConfiguration conf = request.sslConfiguration();
    conf.setPeerVerifyMode(QSslSocket::VerifyNone);
    conf.setProtocol(QSsl::TlsV1SslV3);
    request.setSslConfiguration(conf);
    request.setUrl(QUrl("https://www.baidu.com"));
    */
    request.setUrl(QUrl(ui->editGetUrl->text()));
    //设置请求头
    //已知头类型参见文档QNetworkRequest::KnownHeaders
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    //自定义类型
    request.setRawHeader("self-header", "gongjianbo");
    //发送请求
    manager->get(request);
    //同步处理，可以开启一个局部的事件循环，等待响应，不会阻塞线程
    //QNetworkReply *reply=manager->get(request);
    //QEventLoop eventLoop;
    //connect(reply, &QNetworkReply::finished, &eventLoop, &QEventLoop::quit);
    //eventLoop.exec();
    //receiveReply(reply);
    //超时处理，可以使用定时器调用abort、close来终止当前的请求
    //QNetworkReply *reply=manager->get(request);
    //if(reply->isRunning()){
    //    QTimer *timer=new QTimer(reply);//对象树关联释放，也可以在finish进行释放
    //    timer->setSingleShot(true);
    //    //超时就结束
    //    connect(timer,&QTimer::timeout,reply,&QNetworkReply::abort);
    //    //结束就关定时器
    //    connect(reply,&QNetworkReply::finished,timer,&QTimer::stop);
    //    //定时
    //    timer->start(5000);
    //}
}

void MainWidget::postTest()
{
    //构建请求对象
    QNetworkRequest request;
    request.setUrl(QUrl(ui->editPostUrl->text()));
    //设置请求头
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    //发送请求
    manager->post(request, ui->editPostData->toPlainText().toUtf8());
}

void MainWidget::formTest()
{
    QNetworkAccessManager manager2;
    //构建一个multiPart用于提交表单
    //注意，multiPart请在请求完成后再删除
    QHttpMultiPart* multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
    //文本内容
    QHttpPart namePart;
    namePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain"));
    namePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"text\""));
    namePart.setBody("gongjianbo");
    QHttpPart agePart;
    agePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; age=\"age\""));
    agePart.setBody("27");
    multiPart->append(namePart);
    multiPart->append(agePart);
    //文件内容
    QHttpPart filePart;
    filePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain")); //我用application传各种类型文件
    //示例里没有filename，导致提交不成功
    filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"thefile\";filename=\"file.txt\";"));
    QFile* textFile = new QFile("file.txt");
    textFile->setParent(multiPart); //在删除reply时一并释放
    if(textFile->open(QIODevice::ReadOnly))
    {
        //要读取小块数据，请使用setBody(); 对于像图像这样的较大数据块，请使用setBodyDevice()。
        filePart.setBodyDevice(textFile);
        multiPart->append(filePart);
    }
    //图片内容
    QHttpPart imagePart;
    imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/png"));
    //示例里没有filename，导致提交不成功
    imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"image\""));
    QFile* imageFile = new QFile("image.png");
    imageFile->setParent(multiPart); //在删除reply时一并释放
    if(imageFile->open(QIODevice::ReadOnly))
    {
        imagePart.setBodyDevice(imageFile);
        multiPart->append(imagePart);
    }
    //设置边界
    multiPart->setBoundary("qtdata");
    //使用入同步处理:
    QNetworkRequest request(QUrl("https://httpbin.org"));
    request.setRawHeader("Content-Type", "multipart/form-data;boundary=qtdata");
    
    //提交表单
    QNetworkReply* reply = manager2.post(request, multiPart);
    multiPart->setParent(reply); //在删除reply时一并释放
    QEventLoop eventLoop;
    connect(reply, &QNetworkReply::finished, &eventLoop, &QEventLoop::quit);
    eventLoop.exec();
    //处理reply信息
    receiveReply(reply);
    //qDebug() << "reply:" << reply->readAll();
    reply->deleteLater();
}

void MainWidget::receiveReply(QNetworkReply* reply)
{
    //请求方式get、post等，对应QNetworkAccessManager的Operation枚举
    //对于restful接口需要判断此枚举
    qDebug() << "operation:" << reply->operation();
    //路径
    qDebug() << "url:" << reply->url();
    //状态码
    const int status_code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
    qDebug() << "status code:" << status_code;
    //主动调用QNetworkReply的close或者abort也会触发finished，这时状态码为0
    //访问失败状态码也会为0
    if(status_code == 0 && reply->errorString() == "Operation canceled")
    {
        qDebug() << "timeout";
    }
    if(reply->error() != QNetworkReply::NoError)
    {
        //处理中的错误信息
        qDebug() << "reply error:" << reply->errorString();
    }
    else
    {
        //重定向
        /*if (status_code == 301 || status_code == 302){
              // Or the target URL if it was a redirect:
              QVariant redirectionTargetUrl =reply->attribute(QNetworkRequest::RedirectionTargetAttribute);
              //qDebug() << "redirection Url is " << redirectionTargetUrl.toString();
              QUrl url(redirectionTargetUrl.toString());
              manager->get(QNetworkRequest(url));
        }*/
        //获取响应信息并展示到ui，这里没有解析
        const QByteArray reply_data = reply->readAll();  //uir的内容json内容
        //qDebug()<<"read all:"<<reply_data;
        ui->editRecv->append("[Reply] " + QTime::currentTime().toString("hh:mm:ss"));
        //根据自己的编码选用对应的QString方法
        ui->editRecv->append(QString::fromUtf8(reply_data));
        //解析json
//        QJsonParseError json_error;
//        QJsonDocument document = QJsonDocument::fromJson(reply_data, &json_error);
//        if (json_error.error == QJsonParseError::NoError)
//        {
//            if(document.isObject())
//            {
//                const QJsonObject obj = document.object();
//                qDebug() << obj;
//                if(obj.contains("args"))
//                {
//                    QJsonValue value = obj.value("args");
//                    qDebug() << value;
//                    //QJsonValue(object, QJsonObject({"ie":"utf-8"}))
//                }
//            }
//        }
//        else
//        {
//            qDebug() << "json error:" << json_error.errorString();
//        }
    }
    reply->deleteLater();
}
```

![image-20230220215940598](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20230220215940598.png)

### 文件下载

服务器

```python
#using flask 2.0.1
import os,sys
from flask import Flask,request,jsonify,send_file,send_from_directory

app = Flask(__name__)
filename_temp = ''
BASE_PATH=os.path.join(os.path.dirname(os.path.abspath(__file__)),'upload')

#测试
@app.route('/',methods=['GET','POST'])
def hello():
    return '<p>Hello!</p>'

#上传
@app.route('/upload',methods=['POST'])
def upload_file():
    try:
        global filename_temp
        f = request.files['myfile']
        filename_temp = f.filename
        print('upload file:'+f.filename)
        f.save(os.path.join(BASE_PATH,f.filename))
        return jsonify({
            'filename':f.filename,
            'fileid':0 #假装对每个文件返回一个id，然后通过id再下载
        })
    except Exception as e:
        print('error:'+str(e))
        return jsonify({'error':0}),0

#下载
@app.route('/download/<fileid>',methods=['GET'])
def download_file(fileid):
    try:
        global filename_temp
        print('download file:'+filename_temp) #假装是通过id从数据库拿到的文件
        return send_from_directory(BASE_PATH,filename_temp,as_attachment=True)
    except Exception as e:
        print('error:'+str(e))
        return jsonify({'error':0}),0 

if __name__ == '__main__':
    print('server runing... ...')
    if not os.path.exists(BASE_PATH): 
        os.makedirs(BASE_PATH) 
    app.run(host='127.0.0.1',port=12345,debug=True)
```

客户端

```c++
//HttpManager.h
#pragma once
#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QHttpPart>
#include <QHttpMultiPart>
#include <QUrl>
#include <QUrlQuery>
#include <QJsonDocument>
#include <QJsonParseError>
#include <QJsonValue>
#include <QJsonObject>
#include <QJsonArray>
#include <QFile>

class HttpManager : public QObject
{
    Q_OBJECT
public:
    explicit HttpManager(QObject *parent = nullptr);

    Q_INVOKABLE void upload(const QString &url, const QString &filepath);
    Q_INVOKABLE void download(const QString &url, const QString &fileid, const QString &filepath);

private:
    QNetworkAccessManager manager;
};


```

```c++
//mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include "HttpManager.h"

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private:
    Ui::MainWindow *ui;
    HttpManager manager;
};
#endif // MAINWINDOW_H

```

main.cpp

```c++
#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}

```

```c++
// HttpManager.cpp
#include "HttpManager.h"
#include <QEventLoop>
#include <QFileInfo>
#include <QDebug>
#include <QDataStream>

HttpManager::HttpManager(QObject* parent) : QObject(parent)
{
    //QNetworkReply自动释放
    manager.setAutoDeleteReplies(true);
}

// 文件上传
void HttpManager::upload(const QString& url, const QString& filepath)
{
    qDebug() << "[上传文件]" << url << QFileInfo(filepath).fileName();
    QFile* file = new QFile(filepath);
    if(!file->open(QIODevice::ReadOnly))
    {
        file->deleteLater();
        qDebug() << "open file error";
        return;
    }
    QNetworkRequest request;
    request.setUrl(QUrl(url));
    request.setRawHeader("Content-Type", "multipart/form-data");
    //构建一个multiPart用于提交表单
    QHttpMultiPart* multipart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
    //文件内容
    QHttpPart filepart;
    filepart.setHeader(QNetworkRequest::ContentDispositionHeader,
                       QVariant(QString("form-data; name=\"myfile\"; filename=\"%1\";")
                                .arg(QFileInfo(filepath).fileName())));
    //part.header加上这句flask.request.files才能拿到form-data的信息
    //注意不是request的header
    filepart.setRawHeader("Content-Type", "multipart/form-data");
    //
    file->setParent(multipart);   //在删除reply时一并释放
    //要读取小块数据，请使用setBody(); 对于像图像这样的较大数据块，请使用setBodyDevice()。
    filepart.setBodyDevice(file); //
    multipart->append(filepart);
    //提交表单
    QNetworkReply* reply = manager.post(request, multipart);
    multipart->setParent(reply); //在删除reply时一并释放
    //因为是测试所以同步等待
    QEventLoop eventLoop;
    //上传进度
    connect(reply, &QNetworkReply::uploadProgress,
            this, [this](qint64 bytesSent, qint64 bytesTotal)
    {
        qDebug() << "[上传文件] 已下载的字节数:" << bytesSent << "需下载的字节:" << bytesTotal;
    });
    //结束退出事件循环
    connect(reply, &QNetworkReply::finished, &eventLoop, &QEventLoop::quit);
    eventLoop.exec();
    int status_code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(); // 上传状态
    qDebug() << "reply" << status_code << QString(reply->readAll());  //显示上传的json数据
    qDebug() << "[上传文件] 完成!";
    reply->deleteLater();
}

// 下载文件
void HttpManager::download(const QString& url, const QString& fileid, const QString& filepath)
{
    qDebug() << "[下载文件]" << url << fileid;
    QNetworkRequest request;
    request.setUrl(QUrl(url + QString("/%1").arg(fileid)));
    QNetworkReply* reply = manager.get(request);
    //先删除已有的
    QFile file(filepath);
    file.remove();
    //因为是测试所以同步等待
    QEventLoop eventLoop;
    //数据可读
    connect(reply, &QNetworkReply::readyRead, this, [this, reply, &file]()
    {
        if(!reply->isOpen())
        {
            if(!reply->open(QIODevice::ReadOnly))
            {
                qDebug() << "[下载文件] 回复失败";
                return;
            }
        }
        if(!file.isOpen())
        {
            if(!file.open(QIODevice::WriteOnly | QIODevice::Append))
            {
                qDebug() << "[下载文件] 文件打开失败";
                return;
            }
        }
        file.write(reply->readAll());
    });
    //下载进度
    connect(reply, &QNetworkReply::downloadProgress,
            this, [this](qint64 bytesReceived, qint64 bytesTotal)
    {
        qDebug() << "[下载文件] 已下载的字节数:" << bytesReceived << "需下载的字节:" << bytesTotal;
    });
    //结束退出事件循环
    connect(reply, &QNetworkReply::finished, &eventLoop, &QEventLoop::quit);
    eventLoop.exec();
    file.close(); //关闭文件
    int status_code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
    //如果是无效的响应吧数据清除
    if(status_code != 200)
    {
        file.remove();
    }
    qDebug() << "reply" << status_code << QString(reply->readAll());
    qDebug() << "[下载文件] 完成!";
}

```

```c++
//mainwindow.cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QFileDialog>

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    //选择文件
    connect(ui->btnSelect, &QPushButton::clicked, [this]
    {
        const QString filepath = QFileDialog::getOpenFileName(this);
        if(filepath.isEmpty())
            return;
        ui->editFilepath->setText(filepath);
    });
    //上传
    connect(ui->btnUpload, &QPushButton::clicked, [this]
    {
        if(ui->editFilepath->text().isEmpty())
            return;
        const QString filepath = ui->editFilepath->text();
        const QString url = ui->editUrl->text() + "/upload";
        manager.upload(url, filepath);
    });
    //下载
    connect(ui->btnDownload, &QPushButton::clicked, [this]
    {
        if(ui->editFilepath->text().isEmpty())
            return;
        const QString filepath = ui->editFilepath->text();
        QFileInfo info(filepath);
        const QString url = ui->editUrl->text() + "/download";
        manager.download(url, "0", info.dir().absoluteFilePath("download_" + info.fileName()));
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}
```

![image-20230221145043463](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20230221145043463.png)

## QAbstractSocket处理状态

[(14条消息 ) Qt网络编程：QAbstractSocket_友善啊，朋友的博客-CSDN博客_qabstractsocket](https://blog.csdn.net/kenfan1647/article/details/118023765)

[(15条消息) qt有关tcpserver中读取数据时是否使用flush时的研究_-西门吹雪的博客-CSDN博客_qtcpsocket flush函数](https://blog.csdn.net/MMTS_yang/article/details/103199010)

[(15条消息) Socket通信中flush()方法的使用_屈楚的博客-CSDN博客_flush socket](https://blog.csdn.net/jjarchu/article/details/88962817?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-88962817-blog-103199010.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-88962817-blog-103199010.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

[qt有关tcpserver中读取数据时是否使用flush时的研究_-西门吹雪的博客-CSDN博客_qtcpsocket flush函数](https://blog.csdn.net/MMTS_yang/article/details/103199010)

https://blog.csdn.net/kenfan1647/article/details/118314984)

客户端:

```c++
    connect(m_tcpSockt, &QTcpSocket::connected, this, &NetWorkHander::handerConnected);      //连接上了服务器
    connect(m_tcpSockt, &QTcpSocket::stateChanged, this, &NetWorkHander::handerStateChanged);  // 状态改变
    // 第一种方式 connect(m_tcpSockt, SIGNAL(error(QAbstractSocket::SocketError)), this,  SLOT( handerSockcteErrorr(QAbstractSocket::SocketError error)));  // 错误处理
    //第二种方式 // 报错???  connect(m_tcpSockt, &m_tcpSockt::error, this, &NetWorkHander::handerSockcteErrorr);
    // 解决 connect(this,&QAbstractSocket::errorOccurred, this, &SockeClient::onError); //或者 connect(this,QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &SockeClient::onError);
    connect(m_tcpSockt, &QAbstractSocket::errorOccurred, this, &NetWorkHander::handerSockcteErrorr);  // 错误处理


void NetWorkHander::handerSockcteErrorr(QAbstractSocket::SocketError error)
{
    qDebug() << "Error: " << error;  // 打印哪里错了
}

// socket的状态改变
void NetWorkHander::handerStateChanged(QAbstractSocket::SocketState state)
{
    switch (state)
    {
        case QAbstractSocket::UnconnectedState:
            {
                // 未连接
                // 启动定时器去连接
                if (m_timerReconnect)
                {
                    qDebug() << "stock::SocketChange: 没有连接服务器";
                    if (!m_timerReconnect->isActive()) // 定时器没有启动
                    {
                        m_timerReconnect->start(5000);
                    }
                }
                emit connectedStatus(false);  // 发送信号(函数名(信号))
                break;
            }
        case QAbstractSocket::HostLookupState:
            break;
        case QAbstractSocket::ConnectingState:  //ConnectingState找远程port
            {
                // 启动定时器去连接
                if (m_timerReconnect)
                {
                    qDebug() << "stock::SocketChange: 处于连接服务器中";
                    if (!m_timerReconnect->isActive()) // 定时器状态
                    {
                        qDebug() << "---------";
                        m_timerReconnect->start(5000);
                    }
                }
                break;
            }
        case QAbstractSocket::ConnectedState :
            qDebug() << "void  NetWorkHander::handerStateChanged()连接上了";
            emit connectedStatus(true);     // 发送信号
            break;
        case QAbstractSocket::ClosingState:
            break;
        default:
            break;
    }
}

```



```c++
connect(socket_, &QTcpSocket::stateChanged, this, &Client::handerStateChanged);  // 状态改变
connect(socket_, &QAbstractSocket::errorOccurred, this, &Client::handerSockcteErrorr);  // 错误处理
    

// 处理连接错误
void Client::handerSockcteErrorr(QAbstractSocket::SocketError socketError)
{
    switch (socketError)
    {
        case QAbstractSocket::RemoteHostClosedError:
            break;
        case QAbstractSocket::HostNotFoundError:
            QMessageBox::information(this, tr("Fortune Client"),
                                     tr("没有找到服务器。请查看主机名和端口设置"));
            break;
        case QAbstractSocket::ConnectionRefusedError:
            QMessageBox::information(this, tr("Fortune Client"),
                                     tr("The connection was refused by the peer. "
                                        "Make sure the fortune server is running, "
                                        "and check that the host name and port "
                                        "settings are correct."));
            break;
        default:
            QMessageBox::information(this, tr("Fortune Client"),
                                     tr("The following error occurred: %1.")
                                     .arg(socket_->errorString()));
    }
}

// 处理连接状态
void Client::handerStateChanged(QAbstractSocket::SocketState socketState)
{
    switch (socketState)
    {
        case QAbstractSocket::HostLookupState:
        case QAbstractSocket::ConnectingState:
            break;
        case QAbstractSocket::ConnectedState:
            isConnected_ = true;
            break;
        case QAbstractSocket::BoundState:
        case QAbstractSocket::ListeningState:
            break;
        case QAbstractSocket::ClosingState:
        case QAbstractSocket::UnconnectedState:
            {
                isConnected_ = false;
                isRecord_ = false;
                ui->pushButton_record->setText(QString::fromLocal8Bit("录像"));
                break;
            }
        default:
            Q_ASSERT_X(0, "stateChanged", "Unknown socket state!");
    }
}    
```

[(22条消息) QJsonObject的使用示例_Licht小粉的博客-CSDN博客_qjsonobject](https://blog.csdn.net/ligare/article/details/125393450)

##  TCP粘包拆包

<img src="%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20221108201702977.png" alt="image-20221108201702977" style="zoom: 67%;" />







说实话，我一直不清楚什么是粘包，后来弄明白了，就是按照使用数据报的形式使用了数据流，用错了，花时间去理解这种因为错误用法而产生的“粘包”这个词汇，真的没有价值，没有指责谁的意思，粘包这个词就像一个硬币的两面，懂得 TCP 的人，根本不需要知道他的存在，不懂 TCP 的人可以通过这个词找到哪里用错了，也还好吧

不readall就不粘了嘛，多大点事

`TCP`在接收数据时有四种情况：

- 先接收到`data1`、再接收`data2`，正常情况；
- 先接收到`data1`的部分数据，再接收到`data1`的余下部分以及`data2`的全部；
- 先接收到`data1`的全部数据和`data2`的部分数据，再接收到`data2`的部分数据；
- 一次性接收`data1`与`data2`的全部数据。

对于后三种情况，我们都是要进行粘包处理的。



粘包只可能出现在TCP(流式传输)中。 其粘包原因可能是下面两种情况：

- 发送端需要等缓冲区才能发送数据，造成发送时就粘包；
- 接收端未及时接收缓冲区的数据，多包一起接收，造成粘包；

一个数据包由包头跟包体组成，包头中包含包体长度，包体为要发送的数据。发送端将数据打包，接收端将数据接收到缓冲区后，从缓冲区起始处解析数据，先找到包头，然后找到包头中表示包体大小的字段，根据包体大小找到包体数据。

粘包的解决方法:

- 发送端粘包，可以通过程序设置`push`指令，不等缓冲区满就立即发送数据（默认情况是等缓冲区满后再发送）。这种方法对于通信的传输效率会降低，有时也不是百分百能可靠。
- 接收端粘包，可以通过优化程序、精简进程工作量、提高进程优先级等措施，使其及时接收数据。这种方法，你可以发现，有时候也是无法优化的，实现起来会比较难。
- 采用自定义包头结构，人为控制多次合并，来避免粘包问题。这是常用的做法。

**一般，在TCP建立的长连接的一段时间里，要发送不同数据结构的数据时，要充分考虑数据包的分割**。\



**跨语言通信的场景进行大小端字节序的转换**

**总述：**

|      |                        |                                             |
| ---- | ---------------------- | ------------------------------------------- |
|      | 字节间                 | 字节内                                      |
| 大端 | 低地址的数据放在高字节 | 位域：先从低地址对应数据字节的高bit开始分配 |
| 小端 | 低地址的数据放在低字节 | 位域：先从低地址对应数据字节的低bit开始分配 |

注释：
对于大小端的几个结论：
1.char型变量和char型[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)没有大小端的区分。
2.需要转化数据类型大于1个字节的数据类型：short，int，[枚举](https://so.csdn.net/so/search?q=枚举&spm=1001.2101.3001.7020)，联合体等。
**一.进行大小端转化目的**
目前我接触到的，arm是小端，dsp是大端，电脑是小段，网络数据一般为大端，当arm需要和dsp通信的时候就会存在大小端转化的问题，每种芯片为什么选用大小端的由来就不赘述了

c语言大小端转化调用库函数：

|       |                                                              |
| ----- | ------------------------------------------------------------ |
| htonl | host to network ,l代表unsigned long型 也可以看成unsigned int |
| htons | host to network ,s代表unsigned short型                       |
| ntohl | network to host ,l代表unsigned long型 也可以看成unsigned int |
| ntohs | network to host ,s代表unsigned short型                       |

**在网络传输中，一般要求是大端，而inter处理器是小端，network to host理解为大端转小端，而host to network 理解为小端转大端，本质上大端小端的转化算法是一致的，没有区别，**



## 安全套接层办议SSL

用于保障网络数据传输安全，利用数据加密技术，确保数据在网络传输过程中不会被截取及窃听。

###  openssl

[(18条消息) 解决Qt5.12版本OpenSSL不能用问题: qt.network.ssl: QSslSocket::connectToHostEncrypted: TLS initialization faile_DS小龙哥的博客-CSDN博客](https://blog.csdn.net/xiaolong1126626497/article/details/105220160)





# 自定义通信协议

## 概要

**设计了如下的通信格式：**![image-20230224201456483](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20230224201456483.png)==**整个数据包  =  整个数据包大小/待发数据大小 +  数据包的命令类型 +  待发数据**==

## 结构体对齐

对齐:

![image-20230224204559068](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20230224204559068.png)

对齐计算原则:

1.  第一个属性 从偏移量0位置开始存储
2.  第二个属性开始，放在 min( 该类型的大小 ,  对齐模数) 的整数倍上
3.  整体计算完毕后算总大小，结构体总大小必须是 min( 该结构体中最大数据类型 , 对齐模数) 整数倍,不足要补齐

```c++
typedef struct node1
{
	int a; // 0-3
	char b; //  min(1, 8) = 1    // n * 1 > 3 // 4 
	short c; // min(2, 8) = 2    // n * 2 > 4 // 6 - 7
}S1;
//  min(4, 8) = 4  //4*n > 7 所以 8
 
typedef struct node2
{
	char a; // 0
	int b;  // 4/8=4  //4-7
	short c; // 2/8=2 // 8-9
}S2;
// 4/8=4 // n*4 > 9 所以 12
 
typedef struct node3
{
	int a;  // 0 - 3
	short b;  // 2/8=2 // 2*n > 3 // 4 - 6 
	static int c; // 4/8=4 //4*n > 4 // 8 - 11 
}S3;
// 4/8=4   // 4*n > 11  所以 12

//2、结构体嵌套结构体， 按照子结构体最大的类型计算
struct Student2
{
	char a;  // 0 
    //找struct Student最大的类型  double 8
	struct Student b {      
        int a;       // 4/8=4  // 4*n > 8  // 8 - 12
        char b;      // 1/8=1  // 1*n > 12 // 13
        double c;    // 8/8=1  // 8*n > 13 // 16 - 23
        float d;     // 4/8=4  // 4*n > 23 // 24 - 27
    };  
	double c; // 8/8=8 //8*n > 27 // 27 - 31 
};
```

### 设计结构体时的技巧

**将占用空间小的成员尽量集中在一起**

```c++
struct S1
{
	char a;
	char b;
	int c;
};//结构体1      8
struct S2
{
	char a;
	int c;
	char b;
};//结构体2     12
```

### 修改默认对齐数

```c++
#pragma pack(1)//设置默认对齐数为1
struct S2
{
	char a;//1/1->1
	int b;//4/1->1
	char c;//1/1->1
};//6
#pragma pack()//取消设置的默认对齐数，还原为默认
```

**这样设置到结构体的大小就等于sizeof(S2)方便操作**

## 定义协议

```c++
#ifndef Agreement_H_
#define Agreement_H_

// 命令
enum COMMAND
{
    CLIENT_START_MONITOR,   //客户端开始监控
    CLIENT_STOP_MONITOR,    //客户端停止监控
    CLIENT_MOUSEMOVE,       //客户端鼠标移动
};

#pragma pack(1) //设置结构体为1字节对齐
// 数据包

// 消息头
typedef struct HEADMSG
{
    qint64 length;    //数据大小  
    qint64 cmd;       //命令
} HEADMSG;

//数据 
typedef struct DATA
{
    char* data;
} DATA;

#pragma pack()//结束结构体对齐设置

#endif // Agreement_H_
```

## qt收发结构体

注意: qt中只能发QByteArray数据

```c++
/********************构造数据包************************/
struct HEADMSG headMsg;
// 1. 对结构体进行赋值
...
//2. 结构体转QByteArray
QByteArray data;
data.resize(sizeof(struct HEADMSG));
memcpy(data.data(),&headMsg,sizeof(struct HEADMSG));  
//
socket->write(data);//将数据传过去
```

```c++
QByteArray array;
QByteArray data = TcpConnectSocket->readAll();
array.append(data);
if(!array.isEmpty())
{
    array.resize(sizeof(struct HEADMSG));
    char *buf=array.data();
    struct HEADMSG headMsg;
    memcpy(&headMsg,buf,sizeof(struct HEADMSG));
    
    // 之后操作headMsg就行
}
```

## 总结代码

**设计了如下的通信格式：**![image-20230224201456483](%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF.assets/image-20230224201456483.png)==**整个数据包  = [ 整个数据包大小 +  数据包的命令类型 ]+  待发数据**==

使用见代码agreement

### 发送QString字符串

```c++
void mySocket::sendMSG(QString msg, qint64 cmd)
{
    if(!isValid()) //确保连接仍然有效
    {
        qDebug()<<"losing connect.......";
        return;
    }
    
    /********************构造数据包************************/
    qint64 totalBytes = 0;
    QByteArray block; //用于暂存我们要发送的数据
    QDataStream output(&block,QIODevice::WriteOnly);//使用数据流写入数据
    output.setVersion(QDataStream::Qt_5_2);
    
    totalBytes = msg.toUtf8().size(); // 数据大小
 
    //  totalBytes + cmd  构成了包头, 长度为2*qint64 也就是头文件中定义的MINSIZE
    output<< qint64(totalBytes) << qint64(cmd); 
    //
    totalBytes += block.size();//加上上一行内容的长度
    output.device()->seek(0);//回到数据流的开始位置, 将设备的指针位置置为0，方便后面重新给值
    output << totalBytes; //所有内容（msg+cmd+qint64)的长度 数据包长度
    write(block);
    block.resize(0);//清空
    for(int i=0;i<10000;i++); //延时
 
    block = msg.toUtf8();
    write(block);//发送命令内容  // 发送数据
    block.resize(0);
}     


// 不对
// 得到是 数据包总大小、命令信息和实际数据信息的总和
void Method::sendMSG(QTcpSocket* communicateSocket, QString msg, qint64 cmd)
{
    if(!communicateSocket->isValid()) //确保连接仍然有效
    {
        qDebug() << "losing connect.......";
        return;
    }
    /********************构造数据包************************/
    qint64 totalBytes = 0;
    QByteArray block; //用于暂存我们要发送的数据
    QDataStream output(&block, QIODevice::WriteOnly); //使用数据流写入数据
    output.setVersion(QDataStream::Qt_5_2);
    //数据包总大小、 命令信息 和实际数据信息
    output << qint64(0) <<  qint64(0) << msg.toUtf8();
    totalBytes += block.size(); //得到是 数据包总大小、命令信息和实际数据信息的总和
    output.device()->seek(0);  //回到数据流的开始位置
    //用实际的大小信息代替两个qint64(0)空间
    output << totalBytes << qint64(cmd);
    communicateSocket->write(block);
    qDebug() << "写入字符串成功......";
    block.resize(0);//清空
}
```

### 发送QFile文件

```c++
void mySocket::sendQFile(QString path)
{
   QFile localFile(path);
   if(!localFile.open(QFile::ReadOnly))
       return;
   qDebug()<<"open data file success";
 
   qint64 totalBytes = 0;
   QByteArray outBlock;
   QDataStream sendOut(&outBlock,QIODevice::WriteOnly);
   sendOut.setVersion(QDataStream::Qt_5_2);
 
   totalBytes = localFile.size();  // 文件大小
 
   sendOut<<qint64(totalBytes)<<qint64(QFile_send);
   totalBytes += outBlock.size();
   sendOut.device()->seek(0);
   sendOut<<totalBytes;
   write(outBlock);
   outBlock.resize(0);
 
   outBlock = localFile.readAll();
   write(outBlock);
   outBlock.resize(0);
   localFile.close();
}

// 方式2: 
// 不对
void mySocket::sendQFile(QString path)
{
   QFile localFile(path);
   if(!localFile.open(QFile::ReadOnly))
       return;
   qDebug()<<"open data file success";
 
   qint64 totalBytes = 0;
   QByteArray outBlock;
   QDataStream sendOut(&outBlock,QIODevice::WriteOnly);
   sendOut.setVersion(QDataStream::Qt_5_2);
    
    sendOut << qint64(0) << qint64(0) << localFile.readAll();
    totalBytes += outBlock.size();
    sendOut.device()->seek(0);
    sendOut<<totalBytes << qint64(QFile_send);  //QFile_send是命令
    write(outBlock);
    outBlock.resize(0);
    localFile.close();
}
```

### 发送Struct结构体文件

```c++
void mySocket::sendStructData()
{
    if(!isValid())
        return;

    qint64 totalBytes = 2*sizeof(qint64) + sizeof(struct stu_stateData);//整个数据
    
    QByteArray outBlock;
    QDataStream sendOut(&outBlock,QIODevice::WriteOnly);
    sendOut.setVersion(QDataStream::Qt_5_2);
    outBlock.resize(totalBytes);
    //向缓冲区写入文件头  
    sendOut << totalBytes << qint64(Struct_send); // Struct_send是命令
    //向缓冲区写入文件数据
    mutex.lock();
    // 指针偏移2*sizeof(qint64),再拷贝
    memcpy(outBlock.data() + 2*sizeof(qint64),&stateData,sizeof(struct stu_stateData));
    mutex.unlock();
    write(outBlock);
    outBlock.resize(0);
}
```

### 接收QString、QFile 和 Struct结构体

```c++
    qint64 totalBytes;      //一个数据包MSG部分的完整大小
    qint64 recvdBytes;      //已经收到的字节数
    qint64 serverCmd;       //接受数据包的类型
    QByteArray inBlock;     //接受缓冲
    QByteArray m_buffer;    //缓存上一次或多次的未处理的数据
    QFile *localFile;
    QSqlDatabase db;
    QMutex mutex;
```



```c++


void Method::readMsg(QTcpSocket* communicateSocket, QString* resStr, QPixmap* resImage,
                     QString filePath, QString filename, struct stu_stateData* resStructData)
{
    //如果不存在数据，就直接结束
    if(communicateSocket->bytesAvailable() <= 0)
    {
        qDebug() << "不存在数据";
        return;
    }
    //从缓存区中去除数据，但是不确定取出来的字节数
    QByteArray  buffer;
    buffer = communicateSocket->readAll();
    m_buffer.append(buffer);
    unsigned int totalLen = m_buffer.size();  // 缓存中的内容长度
    //这边确实需要利用长度做while循环，因为有可能一下子读取到两条以上的完整记录，就需要进行循环处理了；
    //超过一条完整小于第二条完整记录时，如果已经达到包头长度就先把包头保存下来，整个过程循环往复
    while(totalLen)
    {
        QDataStream packet(m_buffer);    //与QDataStream绑定，方便操作
        packet.setVersion(QDataStream::Qt_5_2);
        //不够包头长度的不处理，结束while循环
        if(totalLen < MINSIZE)  // MINSIZE = [数据包长度, 命令的类型]大小
        {
            break;
        }
        //读出 数据包长度, 命令的类型
        packet >> totalBytes >> Cmd;
        qDebug() << "数据包长度:" << totalBytes << " 命令的类型:" << Cmd;
        //缓存中的内容长度没有达到命令的长度，先结束，等足够了再来解析
        if(totalLen < totalBytes)
        {
            break;
        }
        //足够长了就开始解析
        switch(Cmd)
        {
            case QString_send :    //接收QString
                {
                    qDebug() << "开始接收字符串...";
                    QByteArray datas = m_buffer.mid(MINSIZE, totalBytes - MINSIZE); //读出的数据
                    resStr->append(datas);
                    break;
                }
            case Qimage_send:
                {
                    qDebug() << "开始接收图片...";
                    QByteArray datas = m_buffer.mid(MINSIZE, totalBytes - MINSIZE); //读出的数据
                    QImage imageData = getImage(datas);
                    *resImage = QPixmap::fromImage(imageData);
                    break;
                }
            case Qimages_send:
                {
                    qDebug() << "开始接收一组图片...";
                    QByteArray datas = m_buffer.mid(MINSIZE, totalBytes - MINSIZE); //读出的数据
                    resImage->loadFromData(datas);
                    break;
                }
            case QFile_send :    //接收文件
                {
                    QDir dir(filePath);      //系统文件目录
                    if(!dir.exists())
                    {
                        dir.mkdir(filePath);
                    }
                    qDebug() << "收到文件";
                    qDebug() << "文件大小为：" << totalBytes;
                    QString tmpfileName = QString("%1/%2").arg(filePath).arg(filename);
                    localFile = new QFile(tmpfileName);//真正的文件路径
                    if(!localFile->open(QIODevice::WriteOnly)) //写的方式打开该文件
                    {
                        qDebug() << QString("无法打开文件%1:\n%2.").arg(filename).arg(localFile->errorString());
                        return;
                    }
                    localFile->resize(0);//清空文件
                    QByteArray datas = m_buffer.mid(MINSIZE, totalBytes - MINSIZE); //读出的数据
                    localFile->write(datas);
                    localFile->close();
                    break;
                }
            case Struct_send: //接收结构体
                {
                    //motionData是一个stu_stateData结构体变量
                    QByteArray realStateData = m_buffer.mid(MINSIZE, totalBytes - MINSIZE);
                    if (!realStateData.isEmpty())
                    {
                        realStateData.resize(sizeof(struct stu_stateData));
                        char* buf = realStateData.data();
                        //motionMutex.lock();
                        memcpy(resStructData, buf, sizeof(struct stu_stateData));
                        //motionMutex.unlock();
                        //之后操作headMsg就行
                    }
                    break;
                }
            // 按要求追加命令
            case CLIENT_START_MONITOR:
                {
                    qDebug() << "开启监控...";
                    QByteArray datas = m_buffer.mid(MINSIZE, totalBytes - MINSIZE); //读出的数据
                    resStr->append(datas);
                    break;
                }
        }
        //缓存多余的数据
        buffer = m_buffer.right(totalLen - totalBytes); //截取下一个数据包的数据，留作下次读取
        totalLen = buffer.size();
        //更新多余的数据
        m_buffer = buffer;
    }
}
```

## 例子

### 传输图片1

```c++
void Client::startTransfer()
{
    QDataStream sendOut(&outBlock, QIODevice::WriteOnly);
    sendOut.setVersion(QDataStream::Qt_5_6);
    //获得图片数据
    QImage image(fileName);
    QString imageData = getImageData(image); //png 编码为[base64] QByteArray数据
    // 保留总大小信息空间、图像大小信息空间，然后输入图像信息
    sendOut << qint64(0) << qint64(0) << imageData;
    // 这里的总大小是 总大小信息、图像大小信息和实际图像信息的总和
    totalBytes += outBlock.size();
    sendOut.device()->seek(0);
    // 返回outBolock的开始，用实际的大小信息代替两个qint64(0)空间
    sendOut << totalBytes << qint64((outBlock.size() - sizeof(qint64) * 2));
    //发出readyRead（）信号
    tcpClient->write(outBlock);
    qDebug() << "图片的内容大小: " << qint64((outBlock.size() - sizeof(qint64) * 2)) << endl;
    qDebug() << "整个包的大小: " << totalBytes << endl;
    outBlock.resize(0);
    ui->clientStatusLabel->setText(tr("传送文件 %1 成功").arg(currentImageName));
    totalBytes = 0;
}

QByteArray Client::getImageData(const QImage& image)
{
    QByteArray imageData;
    QBuffer buffer(&imageData);
    image.save(&buffer, "png");
    imageData = imageData.toBase64();
    return imageData;
}
```



```c++
void Server::updateServerProgress()
{
    QDataStream in(tcpServerConnection);
    in.setVersion(QDataStream::Qt_5_6);
    // 如果接收到的数据小于16个字节，保存到来的文件头结构
    if (bytesReceived <= sizeof(qint64) * 2)
    {
        //保存到来的文件头结构   [保留总大小信息空间、图像大小信息空间]
        if((tcpServerConnection->bytesAvailable() >= sizeof(qint64) * 2)
                && (imageSize == 0))
        {
            // 接收数据总大小信息和文件名大小信息
            in >> totalBytes  >> imageSize;
            bytesReceived += sizeof(qint64) * 2;
            if(imageSize == 0)
            {
                ui->serverStatusLabel->setText(tr("显示的图片为空!"));
            }
            qDebug() << "定位点0" << endl;
        }
        // 接受图片
        if((tcpServerConnection->bytesAvailable() >= imageSize)
                && (imageSize != 0))
        {
            // 接收文件名，并建立文件
            in >> imageContent;
//            qDebug() << imageContent << endl;
            ui->serverStatusLabel->setText(tr("接收文件 …"));
            QImage imageData = getImage(imageContent);
            QPixmap resImage = QPixmap::fromImage(imageData);
            QPixmap* imgPointer = &resImage;
            imgPointer->scaled(ui->imageLabel->size(), Qt::IgnoreAspectRatio);//重新调整图像大小以适应窗口
            imgPointer->scaled(ui->imageLabel->size(), Qt::KeepAspectRatio);//设置pixmap缩放的尺寸
            ui->imageLabel->setScaledContents(true);//设置label的属性,能够缩放pixmap充满整个可用的空间。
            ui->imageLabel->setPixmap(*imgPointer);
     
            bytesReceived += imageSize;
            qDebug() << "定位1  bytesReceived: " << bytesReceived << endl;
            if(bytesReceived == totalBytes)
            {
                ui->serverStatusLabel->setText(tr("接收文件成功"));
                totalBytes = 0;
                bytesReceived = 0;
                imageSize = 0;
            }
        }
    }
}


QImage Server::getImage(const QString& data)
{
    QByteArray imageData = QByteArray::fromBase64(data.toLatin1());
    QImage image;
    image.loadFromData(imageData);
    return image;
}
```

### 传输图片2

```c++
void Client::processData()
{
    int headerLength = sizeof(quint64) + 2;  //10个字节 [图片大小 消息头]的大小
    while (true)
    {
        // 如果接收到的数据小于[图片大小 消息头]的大小, 不读取
        if (receiveData_.size() <= headerLength)
        {
            return;
        }
        int totalLenth = receiveData_.length();
        // 判断得到的消息头是HT
        if (receiveData_.at(0) == 'H' && receiveData_.at(1) == 'T')
        {
            //得到图片大小
            int dataLength = 0;
            QByteArray intbytes = receiveData_.mid(2, sizeof(quint64)); //
            memcpy(&(dataLength), intbytes.data(), intbytes.size());
            // 图片
            if (totalLenth > headerLength + dataLength)
            {
                QByteArray picData = receiveData_.mid(headerLength, dataLength);
                showPic_.loadFromData(picData); //从QByteArray中加载
                showPixmap(&showPic_);
                receiveData_.remove(0, headerLength + dataLength);
            }
            //qDebug() << "left length:" << receiveData_.length();
            return;
        }
        else
        {
            receiveData_.remove(0, 1);
            qDebug() << "remove ";
        }
    }
}

```



```c++
void Server::sendData()
{
    // 锁定鼠标, isLockMouse_由upd决定
    if (isLockMouse_)
    {
        lockTimes_++;
        if (lockTimes_ > 3000)
        {
            isLockMouse_ = false;
            lockTimes_ = 0; // 锁定鼠标
        }
        lockMouse();
    }
    else
    {
        lockTimes_ = 0;
    }
    QByteArray data;
    g_bufferLocker_.lock();
    if (g_BufferList_.size() > 0)
    {
        data = g_BufferList_.takeFirst();  // list[0], 发的是图片
    }
    g_bufferLocker_.unlock();
    if (data.length() > 0 && clientMap_.size() > 0)
    {
        // 如果有数据有客户端, 向所有客户端发送
        QList<QTcpSocket*> clients = clientMap_.values(); // 返回list
        foreach (QTcpSocket* client, clients)
        {
            quint64 length = data.size();
            //size 图片大小
            QByteArray array;
            array.setRawData((char*) & (length), sizeof(length)); // 图片大小
            data.prepend(array); //放在前面
            //header 消息头
            data.prepend("HT");
            quint64 size = client->write(data);  //发送数据
            qDebug() << "发送数据大小: " << size << " 到 " << client->peerAddress().toString();
        }
        //  消息头 图片大小  图片数据
    }
}

```

# 总结

服务器常用操作:   

+ 服务器都得有处理多的客户端的能力,具体操作就是用QVerctor< QTcpSocket>数组保存检测到的通讯套接字或者用QMap<QString,  QTcpSocket>   

QTcpServer 监听后几乎没用他的地方了

bytesAvailable()  返回数据大小

QAbstractSocket 处理状态

```c++
if(!communicateSocket->isValid()) //确保连接仍然有效
{
    qDebug() << "losing connect.......";
    return;
}
```

write() 一般和定时器配套使用

reed() 则放在&QTcpSocket::readyRead槽函数中

QxxxSocket 都能得到自身的ip和端口

服务器和客户端设计思路:

+ 客户端与客户端,要使用web服务器,通过写获取主机的ip,端口号文件,客户端发送给服务器,让服务器进行交互

+ 固定服务器,检测多个客户端,在客户端的配置文件中写死服务器ip
+ 多个客户端,检测服务器，通过udp告诉客户端,服务器ip